---
title: "Getting started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  # collapse = TRUE,
  # comment = "#>",
  message = FALSE, 
  warning = FALSE, 
  # eval = identical(Sys.getenv("NOT_CRAN"), "true"),
  dev = "png",
  dpi = 120,
  fig.asp = 0.4,
  fig.width = 10,
  out.width = "100%",
  fig.align = "center"
)
options(crayon.enabled = TRUE)
options(pillar.bold = TRUE, pillar.subtle_num = TRUE)
# library(dplyr)
# tuangi <-
#   readRDS('../macrofauna/cockles-sst.rds') %>%
#   select(-id, -ym) %>%
#   select(year,
#          lon,
#          lat,
#          count,
#          mud_pct,
#          tn_conc,
#          toc_pct,
#          tp_conc,
#          sst_min,
#          sst_avg,
#          sst_max)
# usethis::use_data(tuangi, overwrite = TRUE)
```

## Overview

This vignette presents a minimal workflow for modelling the distribution of a species abundance along an environmental gradient. See ...

Define y, x, mu, ....

```{r, echo=FALSE, out.height="100%", fig.cap=paste0('Blah balha')}
htmltools::tags$img(src = '../../docs/workflow.JPG')
```

The rest of this vignette proceeds as follows ...

## Load packages and stan files

```{r setup}
library(modskurt)
library(ggplot2)
# only needs to be run every time package installed or updated
compile_stanmodels()

# for reproducibility
set.seed(123456)
```

## Case study - Tuangi vs. mud

The NZ cockle vs sediment mud content.

```{r data}
data(tuangi)
tuangi
```

## A. Specify initial model

```{r model}
spec <-
  mskt_spec(data = tuangi,
            # response and gradients (optional names for tidier outputs)
            y = c('Tuangi (count)' = 'count'),
            x = c('Mud (%)' = 'mud_pct'),
            # distribution of abundance
            dist = 'nb',
            # shape of dist mean function, see ?mskt_shape()
            shape = 'rdp',
            # make predictions for every 1% of mud content
            pred_grid = 0:100)
str(spec)
```

## B. Verify initial model specification

```{r check-model}
check_prior_dens(spec)
# check_prior_mskt(spec) # preds (cover all possible)
# check_prior_dist(spec) # ymax (severe tests)
# check_prior_zero(spec) # zi link
# OPTIONAL: refine model spec
```

## C. Fit subset model

```{r fit-subset, results='hide'}
fit_train <-
  mskt_fit(spec,
           # set the training sample
           train_prop = 0.3,
           iter_warmup = 200,
           iter_sampling = 100,
           chains = 6,
           parallel_chains = 6,
           # for testing
           show_messages = TRUE, show_exceptions = TRUE)
# OPTIONAL: refine model spec or fit parameters
```

```{r fit-subset-check}
check_computation(fit_train)
# OPTIONAL: refine model spec or fit parameters
```

### Check subset model

```{r check-subset-fit}
# check_post_dens(fit_train)
# check_post_dist(fit_train)
# check_post_zero(fit_train)
# uses test set for discrete pit
# check_post_calibration(fit_train)
# OPTIONAL: refine model spec or fit parameters
```

## D. Fit full model

```{r fit-full, results='hide'}
fit_full <-
  mskt_fit(spec,
           chains = 4,
           parallel_chains = 4,
           # for testing
           show_messages = TRUE, show_exceptions = TRUE)
```

```{r fit-full-check}
check_computation(fit_full)
# OPTIONAL: refine model spec or fit parameters
```

### Check full model

```{r check-full-fit}
# check_post_dens(fit_full)
# check_post_dist(fit_full)
# check_post_zero(fit_full)
# uses loocv for discrete pit and pareto-k
# check_post_calibration(fit_train)
# check_post_influencers(fit_train)
# OPTIONAL: refine model spec or fit parameters
```

## E. Use the model

### Plot summaries of the abundance distribution

```{r use-full-fit-dist}
# plot the distribution of abundance along the gradient
abundance_dist(fit_full,
               summaries = c('mean', 'median', 'q90'),
               # whether to use expectations and quantiles from nb or zinbl
               include_zero_inflation = TRUE)
```

### Calculate ranges of x for different percentages of abundance measures

```{r use-full-fit-range}
# assess different range measures of abundance along the gradient
abundance_range(fit_full,
                # smallest range with ...
                capture_pct = 75,
                # mean abundance >= % of max abundance (highest mean)
                using_range = 'high_zone',
                # which distribution summary to use
                based_on = 'q90',
                # one-sided threshold or central range
                region = 'centre',
                # whether to use expectations and quantiles from nb or zinbl
                include_zero_inflation = FALSE)
```

### Visually display abundance ranges

```{r use-full-fit-range-plot}
# or plot them as well
# we'll compare high-zone and most-dens here using patchwork
library(patchwork)
(
  abundance_range(fit_full,
                  capture_pct = 75,
                  using_range = 'high_zone',
                  based_on = 'q90',
                  region = 'centre',
                  plotted = TRUE,
                  range_colour = 'red') +
    labs(subtitle = '75% Highest Abundance Zone (HAZ)')
) + (
  abundance_range(fit_full,
                  capture_pct = 75,
                  using_range = 'most_dens',
                  based_on = 'q90',
                  region = 'centre',
                  plotted = TRUE,
                  range_colour = 'blue') +
    labs(y = NULL, subtitle = '75% Abundance Density Limit (ADL)')
) +
  plot_layout(guides = 'collect')
# note how HAZ prefers higher relative abundance summaries as opposed to ADL
# which considers total abundance summaries irrespective of the relative
# abundance at each x (e.g. tuangi appear quite abundant in low mud %, but
# their density along the whole gradient is skewed towards slightly higher mud
# content)
# OPTIONAL (but not advised): refine model spec or fit parameters
```

## Summary

...
